## Recursive Functions
[Recursion](https://www.rubyguides.com/2015/08/ruby-recursion-and-memoization/)

### Enumerable
[Enumerable](https://ruby-doc.org/core-3.1.2/Enumerable.html#method-i-chunk)
Module Enumerable provides methods that are useful to a collection class for:
* Querying
* Fetching
* Searching
* Sorting
* Iterating
*.chunk*
Enumerates over the items, chunking them together based on the return value of the block.
Consecutive elements which return the same block value are chunked together.
Each element in the returned enumerator is a 2-element array consisting of:
* A value returned by the block.
* An array (“chunk”) containing the element for which that value was returned, and all following elements for which the block returned the same value.
```
e = (0..10).chunk {|i| (i/3).floor }
> #<Enumerator: ...>
e.next
> [0, [0, 1, 2]]
e.next
> [1, [3, 4, 5]]
e.next
> [2, [6, 7, 8]]
e.next
> [3, [9, 10]]
```
Method chunk is especially useful for an enumerable that is already sorted. This example counts words for each initial letter in a large array of words:
```
# Get sorted words from a web page.
url = 'https://raw.githubusercontent.com/eneko/data-repository/master/data/words.txt'
words = URI::open(url).readlines

# Make chunks, one for each letter.
e = words.chunk {|word| word.upcase[0] }
> #<Enumerator: ...>

# Display 'A' through 'F'.
e.each {|c, words| p [c, words.length]; break if c == 'F' }

> ["A", 17096]
> ["B", 11070]
> ["C", 19901]
> ["D", 10896]
> ["E", 8736]
> ["F", 6860]
```
You can use the special symbol :_alone to force an element into its own separate chuck:
```
a = [0, 0, 1, 1]
e = a.chunk{|i| i.even? ? :_alone : true }
e.to_a
> [[:_alone, [0]], [:_alone, [0]], [true, [1, 1]]]
```
For example, you can put each line that contains a URL into its own chunk:
```
pattern = /http/
open(filename) { |f|
  f.chunk { |line| line =~ pattern ? :_alone : true }.each { |key, lines|
    pp lines
  }
}
```
You can use the special symbol :_separator or nil to force an element to be ignored (not included in any chunk):
```
a = [0, 0, -1, 1, 1]
e = a.chunk{|i| i < 0 ? :_separator : true }
e.to_a

# -1 is ignored
> [[true, [0, 0]], [true, [1, 1]]]
```
*any*
[Any](https://ruby-doc.org/core-3.1.2/Enumerable.html#method-i-any-3F)
With no argument and no block, returns whether any element is truthy:
```
(1..4).any?
> true
%w[a b c d].any?
> true
[1, false, nil].any?
> true
[].any?
```
With argument pattern and no block, returns whether for any element element, pattern === element:
```
[nil, false, 0].any?(Integer)
> true
[nil, false, 0].any?(Numeric)
> true
[nil, false, 0].any?(Float)
> false
%w[bar baz bat bam].any?(/m/)
> true
%w[bar baz bat bam].any?(/foo/)
> false
%w[bar baz bat bam].any?('ba')
> false
{foo: 0, bar: 1, baz: 2}.any?(Array)
> true
{foo: 0, bar: 1, baz: 2}.any?(Hash)
> false
[].any?(Integer)
> false
```
With a block given, returns whether the block returns a truthy value for any element:
```
(1..4).any? {|element| element < 2 }
> true
(1..4).any? {|element| element < 1 }
> false
{foo: 0, bar: 1, baz: 2}.any? {|key, value| value < 1 }
> true
{foo: 0, bar: 1, baz: 2}.any? {|key, value| value < 0 }
> false
```
### Chunk vs Map
### Block
[Block](https://www.rubyguides.com/2016/02/ruby-procs-and-lambdas/#Understanding_Ruby_Blocks)
Ruby blocks are little anonymous functions that can be passed into methods.
Blocks are enclosed in a do / end statement or between brackets {}, and they can have multiple arguments.
The argument names are defined between two pipe | characters.
```
# one line
[1, 2, 3].each { |num| puts num }
[1, 2, 3].each { |<arguments>| <body> }

# multiline
[1, 2, 3].each do |num|
  puts num
end
```
A Ruby block is useful because it allows you to save a bit of logic (code) & use it later.
This could be something like writing data to a file, comparing if one element is equal to another, or even printing an error message.
&block as parameter y usar yield, block.call
